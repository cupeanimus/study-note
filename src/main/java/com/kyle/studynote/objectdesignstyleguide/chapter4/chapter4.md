4. 객체 다루기

4.1 개체 : 변경을 추적하고 이벤트를 기록하는 식별 가능한 객체(table)
개체 - 예약, 주문, 청구서, 제품, 고객 등 비즈니스 도메인의 중요한 개념을 나타내며, 개발자가 비즈니스 도메인에 대해 얻은 지식을 모델로 한다(Enity class)
개체는 시간에 따라 변할 수 있지만, 변화를 겪더라도 항상 돌일한 객체여야 한다. <- 개체가 식별 가능해야 하는 이유 (객체를 생성할 때는 식별자를 부여한다)

4.2 값 객체: 교체할 수 있고 익명이며 변경 불가능한 값
값 객체 - 속성이 하나 혹은 둘 뿐이며 훨씬 더 작다. 
ex) SalesInvoice 개체 내 판매 청구서의 Id, 생성날짜, 제품별 Id, 수량 등(Column or field)
 
4.3 데이터 전송 객체: 디자인 규칙이 적은 단순한 객체(DTO)
불변 객체로 구현하길 선호하지만 이런 보호 수준으로는 종종 다른 특성을 방해한다.(점진적으로 값을 채울 때)
읽기 전용/ 한 번만 기록 가능(final)을 표시하는 방법으로 DTO에 사용하는 것이 현명하다.
데이터 전송 객체에는 개체와 값 객체만큼 디자인 규칙이 없다. 

4.4 변경 불가능 객체가 우선이다
-값을 변경 하면 추적이 힘들고 혼란이 올 수 있다

4.4.1 값을 변경하는 대신 교체한다 (최근 코딩 때 신경쓰는 부분. 기존에는 DTO에서 메모리 낭비라 생각하여 수정을 하였다)

    final class Year{
        private int year;
        
        public Year(int year){
        this.year = year;
        }
        
        public Year next(){
        return new Year(this.year +1);
        }
        
    }
    
    Year year = new Year(2019);
    
    year.next();
    assterEquals(new Year(2019), year);
    
    Year nextYear = year.next();
    assterEquals(new Year(2020), nextYear);
변경 불가능 객체는 어떻게 결정하나?
서비스 객체 - 변경 불가능
개체 - 변경 가능
객체 타입 - 변경 불가능

엘레강트 오브젝트 책을 최근에 읽으면서 정립한 생각과 일치하다.      
    
    
    


    