4. 객체 다루기

4.1 개체 : 변경을 추적하고 이벤트를 기록하는 식별 가능한 객체(table)
개체 - 예약, 주문, 청구서, 제품, 고객 등 비즈니스 도메인의 중요한 개념을 나타내며, 개발자가 비즈니스 도메인에 대해 얻은 지식을 모델로 한다(Enity class)
개체는 시간에 따라 변할 수 있지만, 변화를 겪더라도 항상 돌일한 객체여야 한다. <- 개체가 식별 가능해야 하는 이유 (객체를 생성할 때는 식별자를 부여한다)

4.2 값 객체: 교체할 수 있고 익명이며 변경 불가능한 값
값 객체 - 속성이 하나 혹은 둘 뿐이며 훨씬 더 작다. 
ex) SalesInvoice 개체 내 판매 청구서의 Id, 생성날짜, 제품별 Id, 수량 등(Column or field)
 
4.3 데이터 전송 객체: 디자인 규칙이 적은 단순한 객체(DTO)
불변 객체로 구현하길 선호하지만 이런 보호 수준으로는 종종 다른 특성을 방해한다.(점진적으로 값을 채울 때)
읽기 전용/ 한 번만 기록 가능(final)을 표시하는 방법으로 DTO에 사용하는 것이 현명하다.
데이터 전송 객체에는 개체와 값 객체만큼 디자인 규칙이 없다. 

4.4 변경 불가능 객체가 우선이다
-값을 변경 하면 추적이 힘들고 혼란이 올 수 있다

4.4.1 값을 변경하는 대신 교체한다 (최근 코딩 때 신경쓰는 부분. 기존에는 DTO에서 메모리 낭비라 생각하여 수정을 하였다)

    final class Year{
        private int year;
        
        public Year(int year){
        this.year = year;
        }
        
        public Year next(){
        return new Year(this.year +1);
        }
        
    }
    
    Year year = new Year(2019);
    
    year.next();
    assterEquals(new Year(2019), year);
    
    Year nextYear = year.next();
    assterEquals(new Year(2020), nextYear);
변경 불가능 객체는 어떻게 결정하나?
서비스 객체 - 변경 불가능
개체 - 변경 가능
객체 타입 - 변경 불가능

엘레강트 오브젝트 책을 최근에 읽으면서 정립한 생각과 일치하다.      
    
4.5 변경 불가능 객체의 변경자는 변경한 복사본을 반환해야 한다
-객체 값을 변경할 때, 계산을 클라이언트가 하지않고 객체에 변경 메서드를 두어 객체에게 맡긴다.

4.6 변경 가능 객체의 변경자 메서드는 명령 메서드여야 한다
-거의 모든 객체는 변경 불가능해야 하지만, 개체는 그러지 않다. 
이와같은 경우 변경해야한다면 명령 메서드여야 한다.

명령 메서드    
-이름이 명령형이다.
-내부 데이터 구조를 변경 할수 있다. 
-아무것도 반환하지 않는다(void)

4.7 변경 불가능 객체의 변경자 메서드 이름은 서술형이어야 한다
명령 메서드와 혼란을 피하기 위해 이름을 지으려면 '이 ...을 원한다, 하지만 ...'  템플릿을 채워본다.
ex) moveLeft() -> toTheLeft()
~할 것을 알려주는게 아니라 조작 결과를 선언한다

좋은 이름을 찾을 때는 해당 기술 도메인의 일반적인 이름 대신 도메인별 고수준의 이름을 목표로 한다.
ex) withXDecreasedBy() 대신 toTheLeft()를 선택한 것은 추상화 수준이 다르기 때문
-> 내부까지 고려하느냐, 객체만 오롯이 보느냐로 이해된다.

4.8 객체 전체를 비교한다

4.9 변경 불가능 객체를 비교할 때는 동일성이 아닌 상등을 확인한다
변경 불가능 객체를 비교할 때는, 테스트에서 여러 객체의 메모리 참조 위치가 동일하지 않도록 해야한다.
중요한 것은 객체가 나타내는 내용이다.
(equals() 사용)

4.10 변경자 메서드를 호출한 결과는 항상 유효한 객체어야 한다
-오브젝트 관련 책들에서 항상 강조하는 객체의 신뢰성
내용은 유효한지 인자를 확인한다. 생성자 메서드에서 확인을 추천

4.11 변경자 메서드는 상태 변경 요청이 유효한지 확인해야 한다.
-ex) 배달 완료 된 주문은 취소가 불가능하다. 주문을 취소했으면 배송할 수 없다 등

4.12 내부에 기록한 이벤트를 사용해 변경 가능 객체의 변경을 확인한다
객체 생성을 검증할 때 객체를 비교하거나, 해당 값을 변경할 수 도있지만 객체 내부에 이벤트를 기록하여 이벤트를 비교하는 방법도 있다.
하지만 객체 생성까지도 테스트해야할까? 검증 이후에도 계속 이벤트를 남겨야할까? 하는 의문은 든다

4.13 변경 가능 객체에는 흐름식 인터페이스를 구현하지 않는다
호출하는 객체가 무엇인지 혼란스러울 수 있기 때문

오브젝트 관련 공부를 하다보면 강조하는 것은 하나로 귀결된다.
객체는 명확해야한다. 그리고 가장 큰 이유 혹은 효과는 유지보수이다.

 



    
    


    