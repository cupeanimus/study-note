3.5 절대 getter와 setter를 사용하지 말자

3.5.1 객체 대 자료구조
객체와 자료구조의 차이점은 무엇이고, 자료구조가 OOP에서 해로운 이유는 무엇일까?
우선 객체와 자료구조의 차이점을 설명하자면,

    C
    struct Cash {
        int dollars;
    }
    
    printf("Cash value is %d", cash.dollars;
    
    C++
    #include <string>
    class Cash {
    public:
        Cash(int v): dollars(v) {};
        std:string print() const;
        private:
            int dollars;
        };    
    
    printf("Cash value is %s", cash.print());

차이점을 보면 struct의 경우 멤버인 dollars에 직접 접근한 후 해당 값을 정수로 취급하고, struct를 가지고는 어떤 일도 하지 않는다.

클래스는 다르다. 클래스는 어떤 식으로든 멤버에게 접근하는 것을 허용하지 않는다. 게다가 자신의 멤버를 노출하지도 않는다.
print()가 실제로 어떤 방식으로 동작하는 지도 알 수 없고, 캡슐화된 어떤 멤버가 이 작업에 개입하는 지도 알 수 없다. 이것이 바로 캡슐화이고 OOP가 지향하는 가장 중요한 설계 원칙 중 하나이다.
자료구조는 투명하지만 객체는 불투명하다.
자료구조는 글래스박스이지만 객체는 블랙박스이다.
자료구조는 수동적이지만 객체는 능동적이다.
자료구조는 죽어어있지만 객체는 살아있다.

(이러한 차이점들로) 자료구조보다 객체가 더 좋다고 생각한다.
어째서 객체와 자료구조를 동시에 가질 수 없을까? (객체만 사용하는 것이 더 좋기 때문)

절차적 프로그래밍이든, 함수형 프로그래밍이든, 객체지향 프로그래밍이든 모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다.
특정한 시점에 이해해야 하는 범위가 작을수록, 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기도 쉬워진다.

3.2.1에서 절차적인 프로그래밍과 객체지향 프로그래밍 사이의 차이점을 살펴보면서 절차적인 세상보다 더 단순한 세상을 창조하기 위해 OOP가 발명된 것을 알 수 있었다.
OOP에서는 코드가 데이터를 지배하지 않는다. 대신 필요한 시점에 객체가 자신의 코드를 실행시킨다.
OOP에서 바이트보다 더 복잡한 요소를 사용할 때마다, 우리는 절차적인 프로그래밍을 향해 퇴보한다. 바이트들을 자료구조로 묶어 객체 사이의 의사소통에 사용하기 시작하면, 애플리케이션의 전반적인 객체 모델이
심각하게 손상되고 나중에 이를 회복하기도 어려워진다. 프로그래머는 객체와 생성자의 관점이 아니라 구문과 연산자의 관점에서 생각하기 시작한다.

객체지향적이고 선언형 스타일을 유지하기 위해서는, 데이터를 객체 안에 감추고 절대로 외부에 노출해서는 안된다. 정확하게 무엇을 캡슐화하고 있고, 자료구조가 얼마나 복잡한 지는 오직 객체만 알고 있어야 한다.

3.5.2 좋은 의도, 나쁜 결과
getter와 setter를 옹호하는 측에서는 정반대라고 주장하겠지만, 근본적으로 getter와 setter는 캡슐화 원칙을 위반하기 위해 설계 되었다.
Java에서 getter와 setter는 클래스를 자료구조로 바꾸기 위해 도입됐다.

    class Cash {
     public int dollars;
    } 
이와 같이 객체의 프로퍼티들을 public으로 만들면서 클래스를 자료 구조로 바꿀 수 있지만 Java의 프로그래밍 기본 규칙을 심각하게 위반한다.
이런 코드를 본 사람은 프로그래머가 OOP를 제대로 이해하지 못했다고 생각한다. 따라서 public 프로퍼티를 추가해야 하는 어색한 상황을 피하기 위해
프로퍼티를 private로 변경하고 모든 프로퍼티에 getter와 setter를 추가하기로 결정한다. 

필자의 요점은 getter와 setter를 사용하면 OOP의 캡슐화 원칙을 손쉽게 위반할 수 있다는 점이다. 겉으로는 메서드처럼 보이지만 실제로는 우리가 데이터에 직접 접근하고 있다는 불쾌한 현실을 가리고 있을 뿐이다.
이는 행동이 아닌 데이터를 표현 할 뿐이기 때문이다.

3.5.3 접두사에 관한 모든 것
getter/setter 안티 패턴에서 유해한 부분은 두 접두사인 get과 set이라는 사실이 중요하다. 두 접두사는 이 객체가 진짜 객체가 아니고 어떤 존중도 받을 가치가 없는 자료구조라는 사실을 명확하게 전달한다.

어떤 데이터를 반환하는 메서드를 포함하는 것은 괜찮다. 

    class Cash {
        private final int value;
        public int dollars() {
            return this.value;
        }    
    }
하지만 이 메서드의 이름을 다음과 같이 짓는것은 적절하지 않다.

    class Cash {
        private final int value;
        public int getDollars() {
            return this.value;
        }    
    }
필자가 메서드 이름에 지나치게 집착한다 생각할 수 있지만 그렇지 않다. 이 차이는 근본적이며 매우 중요하다.
getDollars()는 "데이터 중에 dollars를 찾은 후 반환하세요" 라고 이야기 하는 것이고 dollars() 는 "얼마나 많은 달러가 필요한가요?" 라고 묻는 것이다(??. 객체를 도구로 보느냐 하나의 존재로 보느냐의 차이?)
dollars()는 객체를 데이터의 저장소로 취급하지 않고 객체를 존중한다. 
사용자는 이 메서드를 통해 얼마나 많은 달러가 포함되어 있는 지 알 수 있지만, 이 값이 private 프로퍼티로 저장되어 있다고 가정하지 않는다. 내부 구조에 관해 어떤 것도 가정하지 않으며, 결코 이 객체르 ㄹ자료구조라고 생각하지 않는다.

dollars()는 데이터를 노출하지 않지만, getDollars()는 데이터를 노출한다. getDollars() 메서드를 통해 데이터가 표면에 완전히 드러나 있으며, 클래스의 모든 사용자를 이 데이터를 볼 수 있다.
(즉 getDollars 를통해 해당 객체에 dollars라는 값이 있다는 것을 알 수 있고, 이 값을 가져온다고 생각하기 때문. 즉 이게 바로 접근과 차이가 무엇인가 라고 말하는 것이라 생각한다.)
결론은 getter와 setter가 OOP에서 끔찍한 안티 패턴이라는 것이다.
(setter를 사용하지 말라는 말은 많이 접했다. 이는 객체의 재사용으로 인한 리크스, 잘못된 코딩이라고 여겼고 피해야 한다고 생각했다. 
하지만 getter를 사용하지 말아야 한다는 말을 보거나 들었을 땐 어떻게? 그럼 대안은? 이라는 의구심을 지울 수 없어고 편리를 위해 사용하는게 좋다고 생각했다.
이 글을 통해 OOP에서 getter역할을 지우라는 것이 아닌 getter 워딩의 의미를 지워야 한다라는 생각을 하게 된다.)
     
                